% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmcmc_control.R
\name{pmcmc_control}
\alias{pmcmc_control}
\title{Control for the pmcmc}
\usage{
pmcmc_control(
  n_steps,
  n_chains = 1L,
  n_threads_total = NULL,
  n_workers = 1L,
  n_steps_each = NULL,
  rerun_every = Inf,
  use_parallel_seed = FALSE,
  save_state = TRUE,
  save_trajectories = FALSE,
  progress = FALSE
)
}
\arguments{
\item{n_steps}{Number of MCMC steps to run. This is the only
required argument.}

\item{n_chains}{Optional integer, indicating the number of chains
to run. If more than one then we run a series of chains and
merge them with \code{\link[=pmcmc_combine]{pmcmc_combine()}}. Chains are run in series,
with the same filter if \code{n_workers} is 1, or run in parallel
otherwise.}

\item{n_threads_total}{If using workers (i.e., \code{n_workers > 1}),
the total number of threads/cores to use. These threads will be
divided evenly across your workers at first and so
\code{n_threads_total} must be an even multiple of \code{n_workers}. If
chains finish at different times (including if \code{n_chains} is not
a multiple of \code{n_workers}) then these threads/cores will be
reallocated across workers, provided that \code{n_steps_each} is
given.}

\item{n_workers}{Number of "worker" processes to use to run chains
in parallel. This must be at most \code{n_chains} and is recommended
to be a divisor of \code{n_chains}. If \code{n_workers} is 1, then chains
are run in series (i.e., one chain after the other).}

\item{n_steps_each}{If using workers (i.e., \code{n_workers > 1}), the
number of steps to run in each "chunk" on each worker before
reporting back to the main process. Increasing this will make
progress reporting less frequent and reduce some communication
overhead (though the overhead is likely to be trivial in any
real application). Decreasing this will give more frequent
process reporting and if \code{n_threads_total} is given will allow
for more rapid re-allocation of unused cores once chains start
finishing. The default, if not given and if \code{n_workers > 1} is
to use 10\% of \code{n_steps}.}

\item{rerun_every}{Optional integer giving the frequency at which
we should rerun the particle filter on the current "accepted"
state.  The default for this (\code{Inf}) will never rerun this
point, but if you set to 100, then every 100 steps we run the
particle filter on both the proposed \emph{and} previously accepted
point before doing the comparison.  This may help "unstick"
chains, at the cost of some bias in the results.}

\item{use_parallel_seed}{Logical, indicating if seeds should be
configured in the same way as when running workers in parallel
(with \code{n_workers > 1}).  Set this to \code{TRUE} to ensure
reproducibility if you use this option sometimes (but not
always). This option only has an effect if \code{n_workers} is 1.}

\item{save_state}{Logical, indicating if the state should be saved
at the end of the simulation. If \code{TRUE}, then a single
randomly selected particle's state will be collected at the end
of each MCMC step. This is the full state (i.e., unaffected by
and \code{index} used in the particle filter) so that the
process may be restarted from this point for projections.  If
\code{save_trajectories} is \code{TRUE} the same particle will
be selected for each. The default is \code{TRUE}, which will
cause \code{n_state} * \code{n_steps} of data to be output
alongside your results. Set this argument to \code{FALSE} to
save space, or use \code{\link[=pmcmc_thin]{pmcmc_thin()}} after running the
MCMC.}

\item{save_trajectories}{Logical, indicating if the particle
trajectories should be saved during the simulation. If \code{TRUE},
then a single randomly selected particle's trajectory will be
collected at the end of each MCMC step.  This is the filtered
state (i.e., using the \code{state} component of \code{index} provided to
the particle filter).  If \code{save_state} is \code{TRUE} the same
particle will be selected for each.}

\item{progress}{Logical, indicating if a progress bar should be
displayed, using \code{\link[progress:progress_bar]{progress::progress_bar}}.}
}
\value{
A \code{pmcmc_control} object, which should not be modified
once created.
}
\description{
Control for the pmcmc. This function constructs a list of options
and does some basic validation to ensure that the options will
work well together. Do not manually change the values in this
object. Do not refer to any argument except \code{n_steps} by position
as the order of the arguments may change in future.
}
\details{
pMCMC is slow and you will want to parallelise it if you possibly
can. There are two ways of doing this which are discussed in some
detail in \code{vignette("parallelisation", package = "mcstate")}.
}
\examples{
mcstate::pmcmc_control(1000)

# Suppose we have a fairly large node with 16 cores and we want to
# run 8 chains. We can use all cores for a single chain and run
# the chains sequentially like this:
mcstate::pmcmc_control(1000, n_chains = 8, n_threads_total = 16)

# However, on some platforms (e.g., Windows) this may only realise
# a 50\% total CPU use, in which case you might benefit from
# splitting these chains over different worker processes (2-4
# workers is likely the largest useful number).
mcstate::pmcmc_control(1000, n_chains = 8, n_threads_total = 16,
                       n_workers = 4)
}
