% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/particle_filter.R
\name{particle_filter}
\alias{particle_filter}
\title{Particle filter}
\description{
Create a \code{particle_filter} object for running
  and interacting with a particle filter.  A higher-level
  interface will be implemented later.
}
\examples{
# A basic SIR model included in the package:
path <- system.file("example/sir/dust_sir.cpp", package = "mcstate")
gen <- dust::dust(path)

# Some data that we will fit to, using 1 particle:
sir <- gen$new(data = NULL, step = 0, n_particles = 1)
dt <- 1/4
day <- seq(1, 100)
incidence <- rep(NA, length(day))
history <- array(NA_real_, c(4, 1, 101))
history[, 1, 1] <- sir$state()
for (i in day) {
   state_start <- sir$state()
   sir$run(i / dt)
   state_end <- sir$state()
   history[, 1, i] <- state_end
   # Reduction in S
   incidence[i] <- state_start[1,1] - state_end[1,1]
 }

# Convert this into our required format:
data_raw <- data.frame(day = day, incidence = incidence)
data <- particle_filter_data(data_raw, "day", 4)

# A comparison function
compare <- function(state, prev_state, observed, pars = NULL) {
  if (is.null(pars)) {
    pars <- list(exp_noise = 1e6)
  }
  incidence_modelled <- prev_state[1,] - state[1,]
  incidence_observed <- observed$incidence
  lambda <- incidence_modelled +
    rexp(n = length(incidence_modelled), rate = pars$exp_noise)
  dpois(x = incidence_observed, lambda = lambda, log = TRUE)
}

# Construct the particle_filter object:
p <- particle_filter$new(data, gen, compare)
p$run(NULL, 100, TRUE)

# Our simulated trajectories, with the "real" data superimposed
matplot(data_raw$day, t(p$history[1, , -1]), type = "l",
         xlab = "Time", ylab = "State",
         col = "#ff000022", lty = 1, ylim = range(p$history))
matlines(data_raw$day, t(p$history[2, , -1]), col = "#ffff0022", lty = 1)
matlines(data_raw$day, t(p$history[3, , -1]), col = "#0000ff22", lty = 1)
matpoints(data_raw$day, t(history[, , -1]), pch = 19,
          col = c("red", "yellow", "blue"))
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{model}}{The dust model generator being simulated (cannot be
re-bound)}

\item{\code{state}}{The final state of the last run of the particle filter}

\item{\code{history}}{The history of the last run of the particle filter
(if enabled with \code{save_history = TRUE}, otherwise NULL}

\item{\code{unique_particles}}{The number of unique particles sampled
at each step that has been run
Create the particle filter}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{particle_filter$new()}}
\item \href{#method-run}{\code{particle_filter$run()}}
\item \href{#method-run2}{\code{particle_filter$run2()}}
\item \href{#method-predict}{\code{particle_filter$predict()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{particle_filter$new(data, model, compare, index = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{The data set to be used for the particle filter.
Must be a \code{\link{data.frame}} with at least columns
\code{step_start} and \code{step_end}.  Additional columns are
used for comparison with the simulation.}

\item{\code{model}}{A stochastic model to use.  Must be a
\code{dust_generator} object.}

\item{\code{compare}}{A comparison function.  Must take arguments
\code{state}, \code{output}, \code{data} and \code{pars} as arguments
(though the arguments may have different names).
\code{state} is the simulated model state (a matrix with as
many rows as there are state variables and as many columns as
there are particles.  \code{output} is the output variables, if
the model produces them (\code{NULL} otherwise) and \code{data}
is a \code{list} of observed data corresponding to the current
time's row in the \code{data} object provided here in the
constructor.  \code{pars} is any additional parameters passed
through to the comparison function (via the \code{pars_compare}
argument to \code{$run}).}

\item{\code{index}}{An index function. This is used to compute the
"interesting" indexes of your model. It must be a function of
one argument, which will be the result of calling the
\code{$info()} method on your model. It should return a list iw
with elements \code{run} (indices to return at the end of each
run, passed through to your compare function) and \code{state}
(indices to return if saving state). These indices can overlap
but do not have to. This argument is optional but using it will
likely speed up your simulation if you have more than a few
states as it will reduce the amount of memory copied back and
forth.
We probably need some special treatment for the initial case
but it's not clear that it belongs here, rather than in some
function above this, as state is just provided here as a vector

Run the particle filter}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run"></a>}}
\if{latex}{\out{\hypertarget{method-run}{}}}
\subsection{Method \code{run()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{particle_filter$run(
  model_data,
  n_particles,
  save_history = FALSE,
  pars_compare = NULL,
  step_start = NULL,
  run_params = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{model_data}}{The data object passed into dust, which may contain
parameters and/or initial conditions}

\item{\code{n_particles}}{The number of particles to simulate}

\item{\code{save_history}}{Logical, indicating if the history of all
particles should be saved}

\item{\code{pars_compare}}{Optional parameters to use when applying
the \code{compare} function.  These parameters will be passed as
the 4th argument to \code{compare}.}

\item{\code{step_start}}{Optional first step to start at.  If provided,
this must be within the range of the first epoch implied in your
\code{data} provided to the constructor (i.e., not less than the
first element of \code{step_start} and less than \code{step_end})}

\item{\code{run_params}}{List containing seed, n_threads and n_generators
for use with dust}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A single numeric value representing the log-likelihood
(\code{-Inf} if the model is impossible)
Run the particle filter, modifying parameters
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run2"></a>}}
\if{latex}{\out{\hypertarget{method-run2}{}}}
\subsection{Method \code{run2()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{particle_filter$run2(
  n_particles,
  save_history = FALSE,
  index,
  pars,
  run_params = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_particles}}{The number of particles to simulate}

\item{\code{save_history}}{Logical, indicating if the history of all
particles should be saved}

\item{\code{index}}{A parameter index}

\item{\code{pars}}{A list of parameters}

\item{\code{run_params}}{List containing seed, n_threads and n_generators
for use with dust

Create predicted trajectories, based on the final point of a
run with the particle filter}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-predict"></a>}}
\if{latex}{\out{\hypertarget{method-predict}{}}}
\subsection{Method \code{predict()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{particle_filter$predict(t, append = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{t}}{The steps to predict from, \emph{offset from the final
point}. As a result the first time-point of \code{t} must be 0.
The predictions will not however, include that point.}

\item{\code{append}}{Logical, indicating if the predictions should be
appended onto the previous history of the simulation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A 3d array with dimensions representing (1) the state
vector, (2) the particle, (3) time
}
}
}
