% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/particle_filter.R
\name{particle_filter}
\alias{particle_filter}
\title{Particle filter}
\description{
Create a \code{particle_filter} object for running
  and interacting with a particle filter.  A higher-level
  interface will be implemented later.
}
\examples{
# A basic SIR model included in the package:
path <- system.file("example/sir/dust_sir.cpp", package = "mcstate")
gen <- dust::dust(path)

# Some data that we will fit to, using 1 particle:
sir <- gen$new(data = list(), step = 0, n_particles = 1)
dt <- 1/4
day <- seq(1, 100)
incidence <- rep(NA, length(day))
true_history <- array(NA_real_, c(4, 1, 101))
true_history[, 1, 1] <- sir$state()
for (i in day) {
  state_start <- sir$state()
  sir$run(i / dt)
  state_end <- sir$state()
  true_history[, 1, i + 1] <- state_end
  # Reduction in S
  incidence[i] <- state_start[1, 1] - state_end[1, 1]
}

# Convert this into our required format:
data_raw <- data.frame(day = day, incidence = incidence)
data <- particle_filter_data(data_raw, "day", 4)

# A comparison function
compare <- function(state, prev_state, observed, pars = NULL) {
  if (is.null(pars$exp_noise)) {
    exp_noise <- 1e6
  } else {
    exp_noise <- pars$exp_noise
  }
  incidence_modelled <- prev_state[1,] - state[1,]
  incidence_observed <- observed$incidence
  lambda <- incidence_modelled +
    rexp(length(incidence_modelled), exp_noise)
  dpois(incidence_observed, lambda, log = TRUE)
}

# Construct the particle_filter object with 100 particles
p <- particle_filter$new(data, gen, 100, compare)
p$run(save_history = TRUE)

# Our simulated trajectories, with the "real" data superimposed
history <- p$history()
matplot(data_raw$day, t(history[1, , -1]), type = "l",
        xlab = "Time", ylab = "State",
        col = "#ff000022", lty = 1, ylim = range(history))
matlines(data_raw$day, t(history[2, , -1]), col = "#ffff0022", lty = 1)
matlines(data_raw$day, t(history[3, , -1]), col = "#0000ff22", lty = 1)
matpoints(data_raw$day, t(true_history[1:3, , -1]), pch = 19,
          col = c("red", "yellow", "blue"))
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{model}}{The dust model generator being simulated (cannot be
re-bound)}

\item{\code{unique_particles}}{The number of unique particles sampled
at each step that has been run}

\item{\code{n_particles}}{Number of particles used (readonly)}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{particle_filter$new()}}
\item \href{#method-run}{\code{particle_filter$run()}}
\item \href{#method-state}{\code{particle_filter$state()}}
\item \href{#method-history}{\code{particle_filter$history()}}
\item \href{#method-predict}{\code{particle_filter$predict()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create the particle filter
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{particle_filter$new(
  data,
  model,
  n_particles,
  compare,
  index = NULL,
  initial = NULL,
  n_threads = 1L,
  seed = 1L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{The data set to be used for the particle filter.
Must be a \code{\link{data.frame}} with at least columns
\code{step_start} and \code{step_end}.  Additional columns are
used for comparison with the simulation.}

\item{\code{model}}{A stochastic model to use.  Must be a
\code{dust_generator} object.}

\item{\code{n_particles}}{The number of particles to simulate}

\item{\code{compare}}{A comparison function.  Must take arguments
\code{state}, \code{output}, \code{data} and \code{pars} as arguments
(though the arguments may have different names).
\code{state} is the simulated model state (a matrix with as
many rows as there are state variables and as many columns as
there are particles.  \code{output} is the output variables, if
the model produces them (\code{NULL} otherwise) and \code{data}
is a \code{list} of observed data corresponding to the current
time's row in the \code{data} object provided here in the
constructor.  \code{pars} is any additional parameters passed
through to the comparison function (via the \code{pars}
argument to \code{$run}).}

\item{\code{index}}{An index function. This is used to compute the
"interesting" indexes of your model. It must be a function of
one argument, which will be the result of calling the
\code{$info()} method on your model. It should return a list
with elements \code{run} (indices to return at the end of each
run, passed through to your compare function) and \code{state}
(indices to return if saving state). These indices can overlap
but do not have to. This argument is optional but using it will
likely speed up your simulation if you have more than a few
states as it will reduce the amount of memory copied back and
forth.}

\item{\code{initial}}{A function to generate initial conditions. If
given, then this function must accept 3 arguments: \code{info}
(the result of calling \code{$info()} as for \code{index}),
\code{n_particles} (the number of particles that the particle
filter is using) and \code{pars} (parameters passed in in the
\code{$run} method via the \code{pars} argument).  It
must return a list, which can have the elements \code{state}
(initial model state, passed to the particle filter - either a
vector or a matrix, and overriding the initial conditions
provided by your model) and \code{step} (the initial step,
overriding the first step of your data - this must occur within
your first epoch in your \code{data} provided to the
constructor, i.e., not less than the first element of
\code{step_start} and not more than \code{step_end}). Your function
can also return a vector or matrix of \code{state} and not alter
the starting step, which is equivalent to returning
\code{list(state = state, step = NULL)}.}

\item{\code{n_threads}}{Number of threads to use when running the
simulation. Defaults to 1, and should not be set higher than the
number of cores available to the machine.}

\item{\code{seed}}{Seed for the random number generator on initial
creation; must be a positive integer. Note that this is unrelated
to R's random number generator (see \code{\link{dust}}).
Run the particle filter}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run"></a>}}
\if{latex}{\out{\hypertarget{method-run}{}}}
\subsection{Method \code{run()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{particle_filter$run(pars = list(), save_history = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pars}}{A list representing parameters. This will be passed as
the \code{pars} argument to your model, to your \code{compare}
function, and (if using) to your \code{initial} function. It must
be an R list (not vector or \code{NULL}) because that is what a
dust model currently requires on initialisation or `$reset` - we
may relax this later. You may want to put your observation and
initial parameters under their own keys (e.g.,
\code{pars$initial$whatever}), but this is up to you. Extra keys
are silently ignored by dust models.}

\item{\code{save_history}}{Logical, indicating if the history of all
particles should be saved. If saving history, then it can be
queried later with the \code{$history} method on the object.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A single numeric value representing the log-likelihood
(\code{-Inf} if the model is impossible)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-state"></a>}}
\if{latex}{\out{\hypertarget{method-state}{}}}
\subsection{Method \code{state()}}{
Extract the current model state, optionally filtering.
If the model has not yet been run, then this method will throw an
error. Returns a matrix with the number of rows being the number of
model states, and the number of columns being the number of
particles.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{particle_filter$state(index_state = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_state}}{Optional vector of states to extract}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-history"></a>}}
\if{latex}{\out{\hypertarget{method-history}{}}}
\subsection{Method \code{history()}}{
Extract the particle trajectories. Requires that
the model was run with \code{save_history = TRUE}, which does
incur a performance cost. This method will throw an error if
the model has not run, or was run without \code{save_history =
TRUE}. Returns a 3d array with dimensions corrsponding to (1)
model state, filtered by \code{index$run} if provided, (2)
particle (following \code{index_particle} if provided), (3)
time point.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{particle_filter$history(index_particle = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_particle}}{Optional vector of particle indices to return.
If \code{NULL} we return all particles' histories.
Create predicted trajectories, based on the final point of a
run with the particle filter}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-predict"></a>}}
\if{latex}{\out{\hypertarget{method-predict}{}}}
\subsection{Method \code{predict()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{particle_filter$predict(t, append = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{t}}{The steps to predict from, \emph{offset from the final
point}. As a result the first time-point of \code{t} must be 0.
The predictions will not however, include that point.}

\item{\code{append}}{Logical, indicating if the predictions should be
appended onto the previous history of the simulation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A 3d array with dimensions representing (1) the state
vector, (2) the particle, (3) time
}
}
}
